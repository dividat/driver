#! /usr/bin/env node --harmony-async-await

const constants = require('../src/constants');
const assert = require('assert');
const prompt = require('prompt');
const semver = require('semver');
const fs = require('fs');
const path = require('path');
const spawnSync = require('child_process').spawnSync;
const execSync = require('child_process').execSync;
const got = require('got');
const uriTemplates = require('uri-templates');
const mime = require('mime-types');

// Setup libraries

prompt.colors = false;
prompt.message = '';

// Start release

const assets = ['build/dist/darwin', 'build/dist/win32/ia32'].reduce(
    (paths, dir) => paths.concat(fs.readdirSync(dir).map(name => path.join(dir, name))),
    []
);

release(
    {
        repo: constants.GH_UPDATE_REPO,
        assets: assets,
        targetBranch: 'windows-installer'
    }
).catch(
    (err) => { console.error(err); process.exit(1); }
);

async function release(options) {
    prompt.start();

    assert.equal(
        spawnSync('git', ['diff-files', '--quiet']).status,
        0,
        "There are uncommited changes."
    );

    const branch = exec('git rev-parse --abbrev-ref HEAD');
    assert.equal(
        branch,
        options.targetBranch,
        `Not on ${options.targetBranch}.`
    );

    const version = (await query('tag', {
        description: 'Please enter semver number for this release',
        conform: semver.valid
    }));
    const tag = 'v' + semver.clean(version);

    assert.equal(
        version,
        require('../package').version,
        'Version must match with package.json.'
    );

    const commit = exec('git rev-parse HEAD');
    console.log(`The latest commit on ${branch} is: \n`);

    console.log(exec(`git show --quiet "${commit}"`) + '\n');

    if (!await decide(`Release this as ${tag}?`, false)) abort();

    console.log('\nCreating draft release ...');

    let response;
    try {
        response = await post(
            `https://api.github.com/repos/${options.repo}/releases`,
            {
                headers: {
                  'content-type': 'application/json'
                },
                body: JSON.stringify({
                    tag_name: tag,
                    target_commitish: commit,
                    name: tag,
                    draft: true
                }),
                json: true
            }
    );
  } catch (err) {
      if (err.response != null) {
          response = err.response;
      } else {
          throw err;
      }
  }

    if (response.statusCode !== 201) {
        console.error(response.body);
        abort(`Failed to create draft. Has ${commit} been pushed?`);
    } else {
        console.log('Success: ' + response.body.html_url);
    }

    console.log('\nUploading assets ...');

    const uriTmpl = uriTemplates(response.body.upload_url);
    await Promise.all(
        options.assets.map((assetPath) => {
            const assetName = path.basename(assetPath);
            const size = fs.statSync(assetPath).size;
            const mimeType = mime.lookup(assetName) || 'application/octet-stream';
            console.log(assetPath, '\t', size, '\t', mimeType);
            return post(
                uriTmpl.fillFromObject({ name: assetName }),
                {
                  headers: {
                      'content-length': size,
                      'content-type': mimeType
                  },
                  body: fs.createReadStream(assetPath)
                }
            );
        })
    );

    console.log('\nFinished. Release draft is at: ' + response.body.html_url);

}


// Helpers


function abort(message) {
    console.log(message || 'Aborting.');
    process.exit(1);
}

function exec(cmd) {
    return execSync(cmd, { encoding: 'utf8' }).trim();
}

async function post(uri, params) {
    if (process.env.GITHUB_RELEASE_TOKEN == null) {
        abort('Need $GITHUB_RELEASE_TOKEN to provide OAuth token.');
    }
    const headers = {
        Authorization: 'token ' + process.env.GITHUB_RELEASE_TOKEN,
        'User-Agent': 'dividat'
    };
    const options = Object.assign(
        {},
        params,
        {
            headers: Object.assign(headers, params.headers)
        }
    );
    return got.post(uri, options);
}

// A slim promisifying wrapper around prompt
async function query(name, properties) {
    return new Promise((resolve, reject) => {
        prompt.get({ properties: { [name]: properties } }, (err, res) => {
            if (err != null) reject(err);
            else resolve(res);
        });
    }).then((res) => res[name]);
}

async function decide(question, defaultDecision) {
    question += defaultDecision === true ? ' [Y/n]' : ' [y/N]';
    return query('q', {
        description: question
    }).then((input) =>
        input === '' ? Boolean(defaultDecision) : /y/i.test(input)
    );
}
